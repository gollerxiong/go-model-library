package tbox

import (
	"database/sql"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	_ "github.com/go-sql-driver/mysql"
)

// engine table to struct data define.
type engine struct {
	dsn string  // mysql dsn
	db  *sql.DB // sql DB

	packageName string // convert to struct package name
	pkgPath     string // gen code to dir path
	isOutputCmd bool   // whether to output to cmd,otherwise output to file
	libPath     string // point the library path relate root path
	projectName string
	conn        string

	addTag bool
	tagKey string // the key value of the tag field, the default is `db:xxx`

	// While the first letter of the field is capitalized
	// whether to convert other letters to lowercase, the default false is not converted
	ucFirstOnly bool

	// Table name returned by TaleName func
	// such as xorm, gorm library uses TableName method to return table name
	enableTableNameFunc bool

	// Whether to add json tag, not added by default
	enableJsonTag bool

	noNullField bool
}

// New create an entry for engine
func New(dsn, projectName, conn string, opts ...Option) *engine {
	if dsn == "" {
		log.Fatalln("dsn is empty")
	}

	t := &engine{
		dsn:         dsn,
		packageName: "models",
		pkgPath:     "./app/models",
		tagKey:      "db",
		addTag:      true,
		libPath:     "./app/library",
		projectName: projectName,
		conn:        conn,
	}

	for _, o := range opts {
		o(t)
	}

	var err error
	t.db, err = t.connect()
	if err != nil {
		log.Fatalln("dsn connect mysql error: ", err)
	}

	if t.pkgPath == "" {
		log.Fatalln("pkg path is empty")
	}

	if !checkPathExist(t.pkgPath) {
		err = os.MkdirAll(t.pkgPath, 0755)
		if err != nil {
			log.Fatalln("create pkg dir error: ", err)
		}
	}

	return t
}

var noNullList = []string{
	"int", "int64", "float", "float32", "json", "string",
}

func (t *engine) getTableCode(tab string, record []columnEntry) []string {
	var header strings.Builder
	header.WriteString(fmt.Sprintf("// Package %s of db entity\n", t.packageName))
	header.WriteString(fmt.Sprintf("// Code generated by go-god/tbox. DO NOT EDIT!!!\n\n"))
	header.WriteString(fmt.Sprintf("package %s\n\n", t.packageName))

	var importBuf strings.Builder
	var tabInfoBuf strings.Builder
	tabPrefix := t.camelCase(tab)
	tabName := tabPrefix + "Table"
	structName := tabPrefix + "Entity"
	tabInfoBuf.WriteString(fmt.Sprintf("// %s for %s\n", tabName, tab))
	tabInfoBuf.WriteString(fmt.Sprintf("const %s = \"%s\"\n\n", tabName, tab))
	tabInfoBuf.WriteString(fmt.Sprintf("// %s for %s table entity struct.\n", structName, tab))
	tabInfoBuf.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	importBuf.WriteString("import (\n\t\"gorm.io/gorm\"\n")
	importBuf.WriteString(fmt.Sprintf("\t\"%s/global\"\n", t.projectName))
	for _, val := range record {
		dataType := getType(val.DataType) // column type
		if dataType == "time.Time" && !strings.Contains(importBuf.String(), "time") {
			importBuf.WriteString("\t\"time\"\n")
		}

		if t.noNullField && strInSet(dataType, noNullList) {
			val.IsNullable = "NO"
		}

		if val.IsNullable == "YES" {
			tabInfoBuf.WriteString(fmt.Sprintf("\t%s\t*%s", t.camelCase(val.Field), dataType))
		} else {
			tabInfoBuf.WriteString(fmt.Sprintf("\t%s\t%s", t.camelCase(val.Field), dataType))
		}

		if t.addTag {
			tabInfoBuf.WriteString("\t")
			tabInfoBuf.WriteString("`")
			if t.enableJsonTag {
				tabInfoBuf.WriteString(fmt.Sprintf("json:\"%s\"", strings.ToLower(val.Field)))
				tabInfoBuf.WriteString(" ")
			}

			if t.tagKey != "" {
				if t.tagKey == "xorm" {
					if val.FieldKey == "PRI" && val.Extra == "auto_increment" {
						tabInfoBuf.WriteString(fmt.Sprintf("%s:\"%s pk autoincr\"", t.tagKey,
							strings.ToLower(val.Field)))
					} else {
						tabInfoBuf.WriteString(fmt.Sprintf("%s:\"%s\"", t.tagKey, strings.ToLower(val.Field)))
					}
				} else if t.tagKey == "gorm" {
					if val.FieldKey == "PRI" && val.Extra == "auto_increment" {
						tabInfoBuf.WriteString(fmt.Sprintf("%s:\"%s primaryKey\"", t.tagKey,
							strings.ToLower(val.Field)))
					} else {
						tabInfoBuf.WriteString(fmt.Sprintf("%s:\"%s\"", t.tagKey, strings.ToLower(val.Field)))
					}
				} else {
					tabInfoBuf.WriteString(fmt.Sprintf("%s:\"%s\"", t.tagKey, strings.ToLower(val.Field)))
				}
			}

			tabInfoBuf.WriteString("`")
		}

		tabInfoBuf.WriteString("\n")
	}

	importBuf.WriteString(")\n\n")
	tabInfoBuf.WriteString("}\n\n")

	tabInfoBuf.WriteString(fmt.Sprintf("\n// %s for %s", "TableName", tab))
	tabInfoBuf.WriteString(fmt.Sprintf("\nfunc (o *%s) TableName() string {\n", structName))
	tabInfoBuf.WriteString(fmt.Sprintf("\treturn %s\n", tabName))
	tabInfoBuf.WriteString("}\n")

	tabInfoBuf.WriteString(fmt.Sprintf("\nfunc (o *%s) GetConn() string {\n", structName))
	tabInfoBuf.WriteString(fmt.Sprintf("\treturn \"%s\"\n", t.conn))
	tabInfoBuf.WriteString("}\n")

	tabInfoBuf.WriteString(fmt.Sprintf("\nfunc (o *%s) GetTable() string {\n", structName))
	tabInfoBuf.WriteString(fmt.Sprintf("\treturn %s\n", tabName))
	tabInfoBuf.WriteString("}\n")

	tabInfoBuf.WriteString(fmt.Sprintf("\nfunc (o *%s) GetModel() (model *gorm.DB) {\n", structName))
	tabInfoBuf.WriteString(fmt.Sprintf("\tmodel = global.App.DbMap[o.GetConn()]\n"))
	tabInfoBuf.WriteString("\treturn\n")
	tabInfoBuf.WriteString("}\n")

	return []string{
		header.String(), importBuf.String(), tabInfoBuf.String(),
	}
}

// Run exec table to struct
func (t *engine) Run(table ...string) error {
	tabColumns, err := t.GetColumns(table...)
	if err != nil {
		return err
	}

	for tab, record := range tabColumns {
		str := strings.Join(t.getTableCode(tab, record), "")
		if t.isOutputCmd {
			fmt.Println(str)
		}

		if !checkPathExist(t.libPath) {
			dir_path := filepath.Join(t.libPath, tab)
			fmt.Println(dir_path)
			//os.Mkdir(dir_path, os.ModePerm)

			err = os.MkdirAll(dir_path, 0755)
			if err != nil {
				log.Fatalln("create pkg dir error: ", err)
			}
		}

		if !checkPathExist(t.pkgPath) {
			fmt.Println(t.pkgPath)
			//os.Mkdir(dir_path, os.ModePerm)

			err = os.MkdirAll(t.pkgPath, 0755)
			if err != nil {
				log.Fatalln("create pkg dir error: ", err)
			}
		}

		// write to file
		var fileName string
		fileName, err = filepath.Abs(filepath.Join(t.pkgPath, strings.ToLower(tab)+"_gen.go"))
		if err != nil {
			log.Println("file path error: ", err)
			continue
		}

		err = os.WriteFile(fileName, []byte(str), 0666)
		if err != nil {
			log.Println("gen code error: ", err)
			return err
		}

		t.createLibrary(tab, record)
	}

	return nil
}

type columnEntry struct {
	TableName    string
	Field        string
	DataType     string
	FieldDesc    string
	FieldKey     string
	OrderBy      int
	IsNullable   string
	MaxLength    sql.NullInt64
	NumericPrec  sql.NullInt64
	NumericScale sql.NullInt64
	Extra        string
	FieldComment string
}

var fields = []string{
	"TABLE_NAME as table_name",
	"COLUMN_NAME as field",
	"DATA_TYPE as data_type",
	"COLUMN_TYPE as field_desc",
	"COLUMN_KEY as field_key",
	"ORDINAL_POSITION as order_by",
	"IS_NULLABLE as is_nullable",
	"CHARACTER_MAXIMUM_LENGTH as max_length",
	"NUMERIC_PRECISION as numeric_prec",
	"NUMERIC_SCALE as numeric_scale",
	"EXTRA as extra",
	"COLUMN_COMMENT as field_comment",
}

// GetColumns Get the information fields related to the table according to the table name
func (t *engine) GetColumns(table ...string) (map[string][]columnEntry, error) {
	var sqlStr = "select " + strings.Join(fields, ",") + " from information_schema.COLUMNS " +
		"WHERE table_schema = DATABASE()"
	if len(table) > 0 {
		sqlStr += " AND TABLE_NAME in (" + t.implodeTable(table...) + ")"
	}

	sqlStr += " order by TABLE_NAME asc, ORDINAL_POSITION asc"
	rows, err := t.db.Query(sqlStr)
	if err != nil {
		log.Println("read table information error: ", err.Error())
		return nil, err
	}

	defer rows.Close()

	records := make(map[string][]columnEntry, 20)
	for rows.Next() {
		col := columnEntry{}
		err = rows.Scan(&col.TableName, &col.Field, &col.DataType, &col.FieldDesc,
			&col.FieldKey, &col.OrderBy, &col.IsNullable, &col.MaxLength, &col.NumericPrec, &col.NumericScale,
			&col.Extra, &col.FieldComment,
		)

		if err != nil {
			log.Println("scan column error: ", err)
			continue
		}

		if _, ok := records[col.TableName]; !ok {
			records[col.TableName] = make([]columnEntry, 0, 20)
		}

		records[col.TableName] = append(records[col.TableName], col)
	}

	return records, nil
}

func (t *engine) connect() (*sql.DB, error) {
	db, err := sql.Open("mysql", t.dsn)
	return db, err
}

func (t *engine) implodeTable(table ...string) string {
	var arr []string
	for _, tab := range table {
		arr = append(arr, fmt.Sprintf("'%s'", tab))
	}

	return strings.Join(arr, ",")
}

func (t *engine) camelCase(str string) string {
	var buf strings.Builder
	arr := strings.Split(str, "_")
	if len(arr) > 0 {
		for _, s := range arr {
			if t.ucFirstOnly {
				buf.WriteString(strings.ToUpper(s[0:1]))
				buf.WriteString(strings.ToLower(s[1:]))
			} else {
				lintStr := lintName(strings.Join([]string{strings.ToUpper(s[0:1]), s[1:]}, ""))
				buf.WriteString(lintStr)
			}
		}
	}

	return buf.String()
}

func (t *engine) createItemFile(tab string, record []columnEntry) {
	str := strings.Builder{}
	file_name := tab + ".go"
	file_path := filepath.Join(t.libPath, tab, file_name)

	str.WriteString(fmt.Sprintf("package %s\n\n", tab))
	str.WriteString(fmt.Sprintf("import (\n"))
	str.WriteString(fmt.Sprintf("\t\"gorm.io/gorm\"\n"))
	str.WriteString(fmt.Sprintf("\t\"%s/app/models\"\n", t.projectName))
	str.WriteString(fmt.Sprintf("\t\"%s/utils\"\n", t.projectName))
	str.WriteString(fmt.Sprintf("\t\"strings\"\n"))
	str.WriteString(fmt.Sprintf(")\n\n\n\n"))

	t.createItemStruct(tab, &str)

	fmt.Println(file_path)

	os.WriteFile(file_path, []byte(str.String()), 0666)
}

func (t *engine) createItemStruct(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("type %s struct {\n", t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\tisNew\tbool\n"))
	b.WriteString(fmt.Sprintf("\tmodel\t*models.%s\n", t.camelCase(tab)+"Entity"))
	b.WriteString(fmt.Sprintf("\tfield\tstring\n"))
	b.WriteString(fmt.Sprintf("\tformatter\t*ModelFormatter\n"))
	b.WriteString(fmt.Sprintf("\tattributes\tmap[string]interface{}\n"))
	b.WriteString(fmt.Sprintf("\toldAttributes\tmap[string]interface{}\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))

	t.createItemSetNew(tab, b)
	return b
}

func (t *engine) createItemSetNew(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) SetNew(n bool) *%s {\n", t.camelCase(tab), t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\to.isNew = n\n"))
	b.WriteString(fmt.Sprintf("\treturn o\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))
	t.createItemIsNew(tab, b)
	return b

}

func (t *engine) createItemIsNew(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) IsNew() bool {\n", t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\treturn o.isNew\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))
	t.createItemGetModel(tab, b)
	return b
}

func (t *engine) createItemGetModel(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) GetModel() *models.%s {\n", t.camelCase(tab), t.camelCase(tab)+"Entity"))
	b.WriteString(fmt.Sprintf("\treturn o.model\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))
	t.createItemSetFields(tab, b)
	return b
}

func (t *engine) createItemSetFields(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) SetField(f string) *%s {\n", t.camelCase(tab), t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\to.field = f\n"))
	b.WriteString(fmt.Sprintf("\treturn o\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))
	t.createItemAddField(tab, b)
	return b
}

func (t *engine) createItemAddField(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) addField(f string) {\n", t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\tif !strings.Contains(o.field, \"*\") {\n"))
	b.WriteString(fmt.Sprintf("\t\to.field += \",\" + f\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))

	t.createItemSetAttributes(tab, b)
	return b
}

func (t *engine) createItemSetAttributes(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) SetAttributes(m map[string]interface{}) *%s {\n", t.camelCase(tab), t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\to.attributes = m\n"))
	b.WriteString(fmt.Sprintf("\treturn o\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))
	t.createItemSetOldAttributes(tab, b)
	return b
}

func (t *engine) createItemSetOldAttributes(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) SetOldAttributes(m map[string]interface{}) *%s {\n", t.camelCase(tab), t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\to.oldAttributes = m\n"))
	b.WriteString(fmt.Sprintf("\treturn o\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))
	t.createItemGetAttributes(tab, b)
	return b
}

func (t *engine) createItemGetAttributes(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) GetAttributes() map[string]interface{} {\n", t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\tresult := make(map[string]interface{})\n"))
	b.WriteString(fmt.Sprintf("\tif !strings.Contains(o.field, \"*\") {\n"))
	b.WriteString(fmt.Sprintf("\t\tfieldArr := strings.Split(o.field, \",\")\n"))
	b.WriteString(fmt.Sprintf("\t\tfor _, key := range fieldArr {\n"))
	b.WriteString(fmt.Sprintf("\t\t\tval, ok := o.attributes[key]\n"))
	b.WriteString(fmt.Sprintf("\t\t\tif ok {\n"))
	b.WriteString(fmt.Sprintf("\t\t\t\tresult[key] = val\n"))
	b.WriteString(fmt.Sprintf("\t\t\t}\n"))
	b.WriteString(fmt.Sprintf("\t\t}\n"))
	b.WriteString(fmt.Sprintf("\t} else {\n"))
	b.WriteString(fmt.Sprintf("\t\tresult = o.attributes\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\to.formatter.SetData(result)\n"))
	b.WriteString(fmt.Sprintf("\tresult = o.formatter.Formate()\n"))
	b.WriteString(fmt.Sprintf("\treturn result\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))
	t.createItemSave(tab, b)
	return b
}

func (t *engine) createItemSave(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) Save() *%s {\n", t.camelCase(tab), t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\tif o.IsNew() {\n"))
	b.WriteString(fmt.Sprintf("\t\tconn.Save(o.model)\n"))
	b.WriteString(fmt.Sprintf("\t} else {\n"))
	b.WriteString(fmt.Sprintf("\t\tdiffMap := utils.DiffMapBaseFirst(o.oldAttributes, o.attributes)\n"))
	b.WriteString(fmt.Sprintf("\t\tkeys := utils.MapKeys(diffMap)\n"))
	b.WriteString(fmt.Sprintf("\t\tconn.Model(&models.%s{}).Where(\"id = ?\", o.model.ID).Select(keys).Updates(diffMap)\n", t.camelCase(tab)+"Entity"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\to.SetNew(false)\n"))
	b.WriteString(fmt.Sprintf("\treturn o\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))

	t.createItemDelete(tab, b)
	return b
}

func (t *engine) createItemDelete(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) Delete() bool {\n", t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\tif o.IsNew() || o.model.ID < 1 {\n"))
	b.WriteString(fmt.Sprintf("\t\treturn true\n"))
	b.WriteString(fmt.Sprintf("\t} else {\n"))
	b.WriteString(fmt.Sprintf("\t\tres := conn.Delete(o.model).Error\n"))
	b.WriteString(fmt.Sprintf("\t\tif res != nil {\n"))
	b.WriteString(fmt.Sprintf("\t\t\treturn false\n"))
	b.WriteString(fmt.Sprintf("\t\t}\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\treturn true\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))
	t.createItemLoadById(tab, b)
	return b
}

func (t *engine) createItemLoadById(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (o *%s) LoadById(id int) *%s {\n", t.camelCase(tab), t.camelCase(tab)))
	b.WriteString(fmt.Sprintf("\tconnection := GetConn().Model(o.model)\n"))
	b.WriteString(fmt.Sprintf("\terr := connection.Where(\"id=?\", id).First(o.model).Error\n"))
	b.WriteString(fmt.Sprintf("\tif err == gorm.ErrRecordNotFound {\n"))
	b.WriteString(fmt.Sprintf("\t\to.SetNew(true)\n"))
	b.WriteString(fmt.Sprintf("\t} else {\n"))
	b.WriteString(fmt.Sprintf("\t\to.SetNew(false)\n"))
	b.WriteString(fmt.Sprintf("\t\tattributes, _ := utils.StructToMap(*o.model)\n"))
	b.WriteString(fmt.Sprintf("\t\to.SetAttributes(attributes)\n"))
	b.WriteString(fmt.Sprintf("\t\to.SetOldAttributes(attributes)\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\treturn o\n}"))

	return b
}

func (t *engine) createCommonFile(tab string, record []columnEntry) {
	str := strings.Builder{}
	file_name := tab + "_common.go"
	file_path := filepath.Join(t.libPath, tab, file_name)

	str.WriteString(fmt.Sprintf("package %s\n\nimport (\n", tab))
	str.WriteString(fmt.Sprintf("\t\"gorm.io/gorm\"\n"))
	str.WriteString(fmt.Sprintf("\t\"%s/app/models\"\n", t.projectName))
	str.WriteString(fmt.Sprintf("\t\"%s/global\"\n", t.projectName))
	str.WriteString(fmt.Sprintf("\t\"strings\"\n"))
	str.WriteString(fmt.Sprintf(")\n\n"))
	str.WriteString(fmt.Sprintf("var field string = \"*\"\n"))
	str.WriteString(fmt.Sprintf("var table string\n"))
	str.WriteString(fmt.Sprintf("var conn *gorm.DB\n"))
	str.WriteString(fmt.Sprintf("var columnFuncMap = make(map[string]func(interface{}) interface{})\n\n"))

	t.createGetConnStr(tab, &str)
	os.WriteFile(file_path, []byte(str.String()), 0666)
}

func (t *engine) createGetConnStr(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func GetConn() *gorm.DB {\n"))
	b.WriteString(fmt.Sprintf("\tif conn == nil {\n"))
	b.WriteString(fmt.Sprintf("\t\tdbmodel := &models.%s{}\n", t.camelCase(tab)+"Entity"))
	b.WriteString(fmt.Sprintf("\t\ttable = dbmodel.GetTable()\n"))
	b.WriteString(fmt.Sprintf("\t\tconnstr := dbmodel.GetConn()\n\n"))
	b.WriteString(fmt.Sprintf("\t\ttmp, ok := global.App.DbMap[connstr]\n\n"))
	b.WriteString(fmt.Sprintf("\t\tif ok {\n"))
	b.WriteString(fmt.Sprintf("\t\t\tconn = tmp\n"))
	b.WriteString(fmt.Sprintf("\t\t}\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\treturn conn\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))

	t.createColumnFormateStr(tab, b)
	return b
}

func (t *engine) createColumnFormateStr(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func columnFormate(key string, value interface{}) interface{} {\n"))
	b.WriteString(fmt.Sprintf("\tkey = strings.ToLower(key)\n"))
	b.WriteString(fmt.Sprintf("\tcallback, ok := columnFuncMap[key]\n\n"))
	b.WriteString(fmt.Sprintf("\tif ok {\n"))
	b.WriteString(fmt.Sprintf("\t\treturn callback(value)\n"))
	b.WriteString(fmt.Sprintf("\t} else {\n"))
	b.WriteString(fmt.Sprintf("\t\treturn value\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))

	return b
}

func (t *engine) createItemConstFile(tab string, record []columnEntry) {
	str := strings.Builder{}
	file_name := fmt.Sprintf("%s_%s.go", tab, "const")
	file_path := filepath.Join(t.libPath, tab, file_name)

	str.WriteString(fmt.Sprintf("package %s\n\n", tab))
	os.WriteFile(file_path, []byte(str.String()), 0666)
}

func (t *engine) createItemFormaterFile(tab string, record []columnEntry) {
	str := strings.Builder{}
	file_name := fmt.Sprintf("%s_%s.go", tab, "formatter")
	file_path := filepath.Join(t.libPath, tab, file_name)

	str.WriteString(fmt.Sprintf("package %s\n\n", tab))
	str.WriteString(fmt.Sprintf("type ModelFormatter struct {\n"))
	str.WriteString(fmt.Sprintf("\t data map[string]interface{}\n"))
	str.WriteString(fmt.Sprintf("}\n\n"))
	str.WriteString(fmt.Sprintf("func (u *ModelFormatter) SetData(data map[string]interface{}) {\n"))
	str.WriteString(fmt.Sprintf("\tu.data = data\n"))
	str.WriteString(fmt.Sprintf("}\n"))
	str.WriteString(fmt.Sprintf("func (u *ModelFormatter) Formate() map[string]interface{} {\n"))
	str.WriteString(fmt.Sprintf("\tvar result = make(map[string]interface{})\n"))
	str.WriteString(fmt.Sprintf("\tfor key, val := range u.data {\n"))
	str.WriteString(fmt.Sprintf("\t\ttmp := columnFormate(key, val)\n"))
	str.WriteString(fmt.Sprintf("\t\tresult[key] = tmp\n"))
	str.WriteString(fmt.Sprintf("\t}\n\n"))
	str.WriteString(fmt.Sprintf("\tu.data = result\n"))
	str.WriteString(fmt.Sprintf("\treturn u.data\n"))
	str.WriteString(fmt.Sprintf("}\n\n\n"))
	os.WriteFile(file_path, []byte(str.String()), 0666)
}

func (t *engine) createItemListFile(tab string, record []columnEntry) {
	str := strings.Builder{}
	file_name := fmt.Sprintf("%s_%s.go", tab, "list")
	file_path := filepath.Join(t.libPath, tab, file_name)

	str.WriteString(fmt.Sprintf("package %s\n\nimport (\n", tab))
	str.WriteString(fmt.Sprintf("\t\"gorm.io/gorm\"\n"))
	str.WriteString(fmt.Sprintf("\t\"%s/app/models\"\n", t.projectName))
	str.WriteString(fmt.Sprintf("\t\"strings\"\n"))
	str.WriteString(fmt.Sprintf(")\n\n"))
	str.WriteString(fmt.Sprintf("type ObjectList struct {\n"))
	str.WriteString(fmt.Sprintf("\tfield\tstring\n"))
	str.WriteString(fmt.Sprintf("\tmodel\t*gorm.DB\n"))
	str.WriteString(fmt.Sprintf("\tpage\tint\n"))
	str.WriteString(fmt.Sprintf("\tpageNate\tbool\n"))
	str.WriteString(fmt.Sprintf("\tpageSize\tint\n"))
	str.WriteString(fmt.Sprintf("\torder\t[]string\n"))
	str.WriteString(fmt.Sprintf("\tids\t[]int\n"))
	str.WriteString(fmt.Sprintf("\tlist\t[]interface{}\n"))
	str.WriteString(fmt.Sprintf("\ttotal\tint64\n"))
	str.WriteString(fmt.Sprintf("\tobjectListFormatter\t*objectListFormatter\n"))
	str.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListSetFieldStr(tab, &str)
	os.WriteFile(file_path, []byte(str.String()), 0666)
}

func (t *engine) createItemListSetFieldStr(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) SetField(f string) *ObjectList {\n"))
	b.WriteString(fmt.Sprintf("\tu.field = f\n"))
	b.WriteString(fmt.Sprintf("\treturn u\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListSetPage(tab, b)
	return b
}

func (t *engine) createItemListSetPage(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) SetPage(page int) *ObjectList {\n"))
	b.WriteString(fmt.Sprintf("\tu.page = page\n"))
	b.WriteString(fmt.Sprintf("\treturn u\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListSetPagenate(tab, b)
	return b
}

func (t *engine) createItemListSetPagenate(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) SetPagenate(p bool) *ObjectList {\n"))
	b.WriteString(fmt.Sprintf("\tu.pageNate = p\n"))
	b.WriteString(fmt.Sprintf("\treturn u\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListSetPageSize(tab, b)
	return b
}

func (t *engine) createItemListSetPageSize(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) SetPageSize(page_size int) *ObjectList {\n"))
	b.WriteString(fmt.Sprintf("\tu.pageSize = page_size\n"))
	b.WriteString(fmt.Sprintf("\treturn u\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListSetOrder(tab, b)
	return b
}

func (t *engine) createItemListSetOrder(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) SetOrder(order string) *ObjectList {\n"))
	b.WriteString(fmt.Sprintf("\tu.order = append(u.order, order)\n"))
	b.WriteString(fmt.Sprintf("\treturn u\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListSetIds(tab, b)
	return b
}

func (t *engine) createItemListSetIds(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) SetIds(ids []int) *ObjectList {\n"))
	b.WriteString(fmt.Sprintf("\tu.ids = ids\n"))
	b.WriteString(fmt.Sprintf("\treturn u\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListgetFormatter(tab, b)
	return b
}

func (t *engine) createItemListgetFormatter(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) getFormatter() *objectListFormatter {\n"))
	b.WriteString(fmt.Sprintf("\treturn u.objectListFormatter\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListaddField(tab, b)
	return b
}

func (t *engine) createItemListaddField(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) addField(f string) {\n"))
	b.WriteString(fmt.Sprintf("\tif !strings.Contains(u.field, \"*\") {\n"))
	b.WriteString(fmt.Sprintf("\t\tu.field += \",\" + f\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListbuildParams(tab, b)
	return b
}

func (t *engine) createItemListbuildParams(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) buildParams() {\n"))
	b.WriteString(fmt.Sprintf("\tif len(u.ids) > 0 {\n"))
	b.WriteString(fmt.Sprintf("\t\tu.model = u.model.Where(\"id in?\", u.ids)\n"))
	b.WriteString(fmt.Sprintf("\t}\n\n"))
	b.WriteString(fmt.Sprintf("\tu.model = u.model.Offset((u.page - 1) * u.pageSize).Limit(u.pageSize)\n\n"))
	b.WriteString(fmt.Sprintf("\tif len(u.order) > 0 {\n"))
	b.WriteString(fmt.Sprintf("\t\tfor _, val := range u.order {\n"))
	b.WriteString(fmt.Sprintf("\t\t\tu.model = u.model.Order(val)\n"))
	b.WriteString(fmt.Sprintf("\t\t}\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListFind(tab, b)
	return b
}

func (t *engine) createItemListFind(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) Find() (userInfoList []map[string]interface{}, total int64) {\n"))
	b.WriteString(fmt.Sprintf("\tu.buildParams()\n\n"))
	b.WriteString(fmt.Sprintf("\tlist := []models.%s{}\n", t.camelCase(tab)+"Entity"))
	b.WriteString(fmt.Sprintf("\tresult := u.model.Find(&list)\n"))
	b.WriteString(fmt.Sprintf("\tformatter := u.getFormatter()\n"))
	b.WriteString(fmt.Sprintf("\tformatter.setList(list)\n"))
	b.WriteString(fmt.Sprintf("\tformatter.setFields(u.field)\n"))
	b.WriteString(fmt.Sprintf("\tuserInfoList = formatter.formate()\n"))
	b.WriteString(fmt.Sprintf("\tu.total = result.RowsAffected\n"))
	b.WriteString(fmt.Sprintf("\ttotal = u.total\n"))
	b.WriteString(fmt.Sprintf("\treturn\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListfilter(tab, b)
	return b
}

func (t *engine) createItemListfilter(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *ObjectList) filter(list []models.%s) (result []map[string]interface{}) {\n", t.camelCase(tab)+"Entity"))
	b.WriteString(fmt.Sprintf("\tfor _, v := range list {\n"))
	b.WriteString(fmt.Sprintf("\t\ttmp, _ := utils.StructToMap(v)\n"))
	b.WriteString(fmt.Sprintf("\t\ttmp = utils.PickFieldsFromMap(tmp, u.field)\n"))
	b.WriteString(fmt.Sprintf("\t\tresult = append(result, tmp)\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\treturn\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListObjectList(tab, b)
	return b
}

func (t *engine) createItemListObjectList(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func NewObjectList() *ObjectList {\n"))
	b.WriteString(fmt.Sprintf("\treturn &ObjectList{\n"))
	b.WriteString(fmt.Sprintf("\t\tfield:\t\"*\",\n"))
	b.WriteString(fmt.Sprintf("\t\tpage:\t1,\n"))
	b.WriteString(fmt.Sprintf("\t\tpageNate:\ttrue,\n"))
	b.WriteString(fmt.Sprintf("\t\tpageSize:\t20,\n"))
	b.WriteString(fmt.Sprintf("\t\tmodel:\tGetConn().Table(table),\n"))
	b.WriteString(fmt.Sprintf("\t\torder:\t[]string{\"id desc\"},\n"))
	b.WriteString(fmt.Sprintf("\t\tlist:     []interface{}{},\n"))
	b.WriteString(fmt.Sprintf("\t\ttotal:    0,\n"))
	b.WriteString(fmt.Sprintf("\t\tobjectListFormatter: newObjectListFormatter(),\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	return b
}

func (t *engine) createItemListFormaterFile(tab string, record []columnEntry) {
	str := strings.Builder{}
	file_name := fmt.Sprintf("%s_%s.go", tab, "list_formatter")
	file_path := filepath.Join(t.libPath, tab, file_name)

	str.WriteString(fmt.Sprintf("package %s\n\nimport (\n", tab))
	str.WriteString(fmt.Sprintf("\t\"%s/app/models\"\n", t.projectName))
	str.WriteString(fmt.Sprintf("\t\"%s/utils\"\n", t.projectName))
	str.WriteString(fmt.Sprintf("\t\"strings\"\n"))
	str.WriteString(fmt.Sprintf("\t\"sync\"\n"))
	str.WriteString(fmt.Sprintf(")\n\n"))
	t.createItemListnewObjectListFormatterStr(tab, &str)
	os.WriteFile(file_path, []byte(str.String()), 0666)
}

func (t *engine) createItemListnewObjectListFormatterStr(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func newObjectListFormatter() (of *objectListFormatter) {\n"))
	b.WriteString(fmt.Sprintf("\tof = &objectListFormatter{}\n"))
	b.WriteString(fmt.Sprintf("\treturn\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListobjectListFormatter(tab, b)
	return b
}

func (t *engine) createItemListobjectListFormatter(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("type objectListFormatter struct {\n"))
	b.WriteString(fmt.Sprintf("\tlist\t[]map[string]interface{}\n"))
	b.WriteString(fmt.Sprintf("\tfields\tstring\n"))
	b.WriteString(fmt.Sprintf("\twg\tsync.WaitGroup\n"))
	b.WriteString(fmt.Sprintf("\tresult\t[]map[string]interface{}\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListsetList(tab, b)
	return b
}

func (t *engine) createItemListsetList(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *objectListFormatter) setList(list []models.%s) {\n", t.camelCase(tab)+"Entity"))
	b.WriteString(fmt.Sprintf("\tvar end = len(list)\n"))
	b.WriteString(fmt.Sprintf("\tvar tmp = make([]map[string]interface{}, end)\n\n"))
	b.WriteString(fmt.Sprintf("\tu.result = tmp\n\n"))
	b.WriteString(fmt.Sprintf("\tfor i := 0; i < end; i++ {\n"))
	b.WriteString(fmt.Sprintf("\t\ttmpmap, _ := utils.StructToMap(list[i])\n"))
	b.WriteString(fmt.Sprintf("\t\ttmp[i] = tmpmap\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("\tu.list = tmp\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))
	t.createItemListsetFields(tab, b)
	return b
}

func (t *engine) createItemListsetFields(tab string, b *strings.Builder) *strings.Builder {
	b.WriteString(fmt.Sprintf("func (u *objectListFormatter) setFields(f string) {\n"))
	b.WriteString(fmt.Sprintf("\tu.fields = f\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))

	b.WriteString(fmt.Sprintf("func (u *objectListFormatter) formate() []map[string]interface{} {\n"))
	b.WriteString(fmt.Sprintf("\tvar length = len(u.list)\n\n"))
	b.WriteString(fmt.Sprintf("\tu.wg.Add(length)\n"))
	b.WriteString(fmt.Sprintf("\tfor i := 0; i < length; i++ {\n"))
	b.WriteString(fmt.Sprintf("\t\tgo u.do(i, u.list[i])\n"))
	b.WriteString(fmt.Sprintf("\t}\n\n"))
	b.WriteString(fmt.Sprintf("\tu.wg.Wait()\n"))
	b.WriteString(fmt.Sprintf("\treturn u.result\n"))
	b.WriteString(fmt.Sprintf("}\n\n"))

	b.WriteString(fmt.Sprintf("func (u *objectListFormatter) do(index int, item map[string]interface{}) {\n"))
	b.WriteString(fmt.Sprintf("\tdefer u.wg.Done()\n"))
	b.WriteString(fmt.Sprintf("\tresult := make(map[string]interface{})\n\n"))
	b.WriteString(fmt.Sprintf("\tif !strings.Contains(u.fields, \"*\") {\n"))
	b.WriteString(fmt.Sprintf("\t\tfieldArr := strings.Split(u.fields, \",\")\n"))
	b.WriteString(fmt.Sprintf("\t\tfor _, key := range fieldArr {\n"))
	b.WriteString(fmt.Sprintf("\t\t\tval, ok := item[key]\n"))
	b.WriteString(fmt.Sprintf("\t\t\tif ok {\n"))
	b.WriteString(fmt.Sprintf("\t\t\t\tresult[key] = columnFormate(key, val)\n"))
	b.WriteString(fmt.Sprintf("\t\t\t}\n"))
	b.WriteString(fmt.Sprintf("\t\t}\n"))
	b.WriteString(fmt.Sprintf("\t\tu.result[index] = result\n"))
	b.WriteString(fmt.Sprintf("\t} else {\n"))
	b.WriteString(fmt.Sprintf("\t\tu.result[index] = item\n"))
	b.WriteString(fmt.Sprintf("\t}\n"))
	b.WriteString(fmt.Sprintf("}\n\n\n"))
	return b
}

func (t *engine) createItemHelperFile(tab string, record []columnEntry) {
	str := strings.Builder{}
	file_name := fmt.Sprintf("%s_%s.go", tab, "helper")
	file_path := filepath.Join(t.libPath, tab, file_name)
	str.WriteString(fmt.Sprintf("package %s\n\n", tab))
	os.WriteFile(file_path, []byte(str.String()), 0666)
}

func (t *engine) createItemBatchOperatorFile(tab string, record []columnEntry) {
	str := strings.Builder{}
	file_name := fmt.Sprintf("%s_%s.go", tab, "batch_operator")
	file_path := filepath.Join(t.libPath, tab, file_name)

	str.WriteString(fmt.Sprintf("package %s\n\nimport (\n", tab))
	str.WriteString(fmt.Sprintf("\t\"gorm.io/gorm\"\n"))
	str.WriteString(fmt.Sprintf("\t\"%s/app/models\"\n", t.projectName))
	str.WriteString(fmt.Sprintf(")\n\n"))

	str.WriteString(fmt.Sprintf("type BatchOperator struct {\n"))
	str.WriteString(fmt.Sprintf("\tfield      string\n"))
	str.WriteString(fmt.Sprintf("\tfieldValue interface{}\n"))
	str.WriteString(fmt.Sprintf("\tmodel      *gorm.DB\n"))
	str.WriteString(fmt.Sprintf("\tids        []int\n"))
	str.WriteString(fmt.Sprintf("}\n\n"))

	str.WriteString(fmt.Sprintf("func NewBatchOperator() *BatchOperator {\n"))
	str.WriteString(fmt.Sprintf("\treturn &BatchOperator{\n"))
	str.WriteString(fmt.Sprintf("\t\tmodel: GetConn(),\n"))
	str.WriteString(fmt.Sprintf("\t}\n"))
	str.WriteString(fmt.Sprintf("}\n\n"))

	str.WriteString(fmt.Sprintf("func (b *BatchOperator) SetFieldValue(v interface{}) *BatchOperator {"))
	str.WriteString(fmt.Sprintf("\tb.fieldValue = v\n"))
	str.WriteString(fmt.Sprintf("\treturn b\n"))
	str.WriteString(fmt.Sprintf("}\n\n"))

	str.WriteString(fmt.Sprintf("func (b *BatchOperator) buildParams() {\n"))
	str.WriteString(fmt.Sprintf("\tif len(b.ids) > 0 {\n"))
	str.WriteString(fmt.Sprintf("\t\tb.model = b.model.Where(\"id in ?\", b.ids)\n"))
	str.WriteString(fmt.Sprintf("\t}\n"))
	str.WriteString(fmt.Sprintf("}\n\n"))

	str.WriteString(fmt.Sprintf("func (b *BatchOperator) Update() bool {\n"))
	str.WriteString(fmt.Sprintf("\tb.buildParams()\n"))
	str.WriteString(fmt.Sprintf("\tb.model.Model(&models.UserBan{}).Update(b.field, b.fieldValue)\n"))
	str.WriteString(fmt.Sprintf("\treturn true\n"))
	str.WriteString(fmt.Sprintf("}\n\n"))

	str.WriteString(fmt.Sprintf("func (b *BatchOperator) Delete() bool {\n"))
	str.WriteString(fmt.Sprintf("\tb.buildParams()\n"))
	str.WriteString(fmt.Sprintf("\tb.model.Delete(&models.UserBan{})\n"))
	str.WriteString(fmt.Sprintf("\treturn true\n"))
	str.WriteString(fmt.Sprintf("}\n\n"))

	os.WriteFile(file_path, []byte(str.String()), 0666)
}

func (t *engine) createLibrary(tab string, record []columnEntry) {
	t.createItemFile(tab, record)
	t.createCommonFile(tab, record)
	t.createItemFormaterFile(tab, record)
	t.createItemListFile(tab, record)
	t.createItemListFormaterFile(tab, record)
	t.createItemHelperFile(tab, record)
	t.createItemBatchOperatorFile(tab, record)
	t.createItemConstFile(tab, record)
}

func checkPathExist(path string) bool {
	_, err := os.Stat(path)
	if err == nil {
		return true
	}

	if os.IsNotExist(err) {
		return false
	}

	return false
}

func strInSet(s string, sets []string) bool {
	for _, member := range sets {
		if s == member {
			return true
		}
	}

	return false
}
